#! /usr/bin/env node

const pckg = require('../package'),
      fs = require('fs'),
      path = require('path'),
      program = require('commander'),
      Kaukau = require('..'),
      logger = require('../lib/logger');

logger.warn("'kaukau' command line is still in development !")

//var directory = ""
//var enableLogs = false, exitOnFail = false, silent = false;

const DEFAULTS = {
  parametersDir: 'config/kaukau'
}

var raw = {

}

var requiredModules = []
var configFile = ""
var parametersDir = ''
var options = {
  /*enableLogs: false,
  exitOnFail: false,
  directory: ""*/
}

program
  .version(pckg.version)
  .usage('[options]')
  .option('-r, --require <names>', 'require the given modules', function(value){
    return value.split(",")
  })
  .option('--directory <name>', 'the folder containing the test files', function(value){
    return path.join( "" , value)
  })
  .option('--config <name>', 'the file containing the main configuration', function(value){
    return path.join( "" , value) || configFile
  })
  .option('--parameters <name>', 'the folder/file containing the parameters', function(value){
    return path.join( "" , value) || parametersDir
  })
  .option('--logs', 'enable logs')
  .option('--exit-on-fail', 'exit after the first set of tests if a test failed')
  .option('--silent', 'silence all console print');


program
  .command('init <path>')
  .option('--directory <name>', 'the folder containing the test files', function(value){
    raw.directory = value
    return path.join( "" , value)
  })
  .option('--config <name>', 'the file containing the main configuration', function(value){
    raw.config = value
    return path.join( "" , value) || configFile
  })
  .option('--parameters <name>', 'the folder containing the parameters files', function(value){
    raw.parameters = value
    return path.join( "" , value) || parametersDir
  })
  .description('create the files and directories')
  .action(function (value) {
    var mkdir = require('mkdirp');

    value = value || "."

    var dirs = {
      "test": path.join(value, program.directory || "test"),
      "parameters": parametersDir ? path.join(value, parametersDir) : path.join(value, DEFAULTS.parametersDir)
    }

    var files = {
      "config": configFile ? path.join(value, configFile) : configFile
    }

    var filesWrite = {
      "config": function(filepath){
        // Change the content of the file as you want
        // or either set fileContent to null to create an empty file
        const contentJSON = '{\n'
        +'\t"enableLogs": false,\n'
        +'\t"exitOnFail": false,\n'
        +'\t"directory": "'+(raw.directory ? raw.directory.replace(/\\/g,'/') : "test")+'",\n'
        +'\t"options": {\n'
        +'\t\t"bail": false,\n'
        +'\t\t"fullTrace": true,\n'
        +'\t\t"grep": "",\n'
        +'\t\t"ignoreLeaks": true,\n'
        +'\t\t"reporter": "spec",\n'
        +'\t\t"retries": 0,\n'
        +'\t\t"slow": 150,\n'
        +'\t\t"timeout": 10000,\n'
        +'\t\t"ui": "bdd",\n'
        +'\t\t"useColors": true\n'
        +'\t}\n'
        +'}'

        const fileContentJS = 'module.exports = '+contentJSON

        try{
          if(filepath && filepath.length > 2 && !fs.existsSync(filepath)){
            var fileContent = fileContentJS
            if(filepath.length >= 5 && filepath.substr(-5) === '.json')
              fileContent = contentJSON
            fs.writeFileSync(filepath, fileContent);
          }
        }catch (e){
            logger.error("Cannot write file ", e);
        }
      }
    }

    Object.keys(dirs).forEach(
      (d) => {
          logger.info(`${d}: ${dirs[d]}`)
          mkdir.sync(dirs[d]);
      }
    )

    Object.keys(files).forEach(
      (f) => {
          if(!files[f]) return;
          mkdir.sync(path.dirname(files[f]))
          if(filesWrite[f]){
            filesWrite[f](files[f])
            logger.info(`${f}: ${files[f]}`)
          }
      }
    )

    process.exit(0)
  });

program.on('option:require', function (value) {
  requiredModules = program.require
});

program.on('option:directory', function (value) {
  options['directory'] = value
});

program.on('option:config', function (value) {
  configFile = value
});

program.on('option:parameters', function (value) {
  parametersDir = value
});

program.on('option:logs', function () {
  options['enableLogs'] = true
});

program.on('option:exit-on-fail', function () {
  options['exitOnFail'] = true
});

program.on('option:silent', function () {
  logger.off()
});

program.parse(process.argv)

requiredModules.forEach(
  function(mod){
    logger.info("--require", mod)
    require(mod)
  }
);

var walkSync = function(dir, filelist, subdir) {
  subdir = subdir || "";
  filelist = filelist || [];
  if(fs.existsSync(dir)){
    var files = fs.readdirSync(dir);
    files.forEach(function(file) {
      if (fs.statSync(path.join(dir, file)).isDirectory()) {
        filelist = walkSync(path.join(dir, file), filelist, path.join(subdir, file));
      }
      else {
        filelist.push(path.join(subdir, file));
      }
    });
  }
  return filelist;
};

// Importing config file

if(configFile){
  try{
    var config = require(path.resolve(configFile));
    Object.keys(config).forEach( p => {
      if(typeof options[p] === 'undefined')
        options[p] = config[p]
    } )
  }catch(e){
    logger.error(`Could not import configuration file '${configFile}'`, e);
  }
}

// Importing parameters

if (parametersDir && fs.existsSync(parametersDir)){
  var param1Join = ""
  var paramsSets = [parametersDir]

  if(fs.statSync(parametersDir).isDirectory()){
    param1Join = parametersDir
    paramsSets = walkSync(parametersDir)
  }

  options.parameters = paramsSets.map((f) => {
    var filepath = path.join(param1Join, f);
    try{
      //logger.log(`Importing parameter file '${filepath}'`);
      return require(path.resolve(filepath));
    }catch(e){
      logger.error(`Could not import parameter file '${filepath}'`, e);
    }
  });
}

var errors = [];

//logger.log(options)
//process.exit(0)
var kaukau = new Kaukau(options);

/**
* Execute Kaukau instance and listen to events
*
* Mocha events:
* - test
* - test end
* - pass
* - fail
* - end
*
* Kaukau events:
* - done
*
*/
kaukau.run()
.on('done', function(){
  var status = "success";
  if(errors.length)
      status = "warn";
  logger[status]("ALL DONE,", errors.length, "errors");
})
.on('fail', function(test){
  errors.push(test);
});
